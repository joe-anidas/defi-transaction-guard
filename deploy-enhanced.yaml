---
version: "2.0"

services:
  defi-guard-ai:
    image: python:3.9-slim
    expose:
      - port: 8080
        as: 80
        to:
          - global: true
      - port: 9090
        as: 9090
        to:
          - global: true
    env:
      - GROK_API=gsk_your_key_here
      - GEMINI_API=your_gemini_key_here
      - BLOCKDAG_API=your_blockdag_key_here
      - BLOCKDAG_RPC=https://rpc.blockdag.network
      - PYTHONUNBUFFERED=1
      - GPU_ACCELERATION=true
      - AI_CACHE_ENABLED=true
    command:
      - "sh"
      - "-c"
    args:
      - |
        pip install flask requests openai google-generativeai groq redis numpy torch
        cat > enhanced_ai_service.py << 'EOF'
        from flask import Flask, request, jsonify
        import os
        import requests
        import json
        import time
        import redis
        import hashlib
        from groq import Groq
        import google.generativeai as genai
        
        app = Flask(__name__)
        
        # Initialize AI clients
        grok_client = None
        gemini_model = None
        redis_client = None
        
        # Initialize Redis cache
        try:
            redis_client = redis.Redis(host='ai-cache-redis', port=6379, decode_responses=True)
            redis_client.ping()
            print("‚úÖ Redis cache connected")
        except:
            print("‚ö†Ô∏è Redis cache not available")
        
        if os.getenv('GROK_API'):
            grok_client = Groq(api_key=os.getenv('GROK_API'))
            
        if os.getenv('GEMINI_API'):
            genai.configure(api_key=os.getenv('GEMINI_API'))
            gemini_model = genai.GenerativeModel('gemini-pro')
        
        @app.route('/health')
        def health():
            return jsonify({
                "status": "healthy", 
                "provider": "akash-gpu-enhanced",
                "grok_available": grok_client is not None,
                "gemini_available": gemini_model is not None,
                "cache_available": redis_client is not None,
                "gpu_enabled": os.getenv('GPU_ACCELERATION') == 'true',
                "blockdag_enabled": bool(os.getenv('BLOCKDAG_API'))
            })
        
        @app.route('/analyze', methods=['POST'])
        def analyze_transaction():
            data = request.json
            start_time = time.time()
            
            # Check cache first
            cache_key = generate_cache_key(data)
            if redis_client:
                try:
                    cached_result = redis_client.get(cache_key)
                    if cached_result:
                        result = json.loads(cached_result)
                        result['cached'] = True
                        result['processTime'] = 5  # Fast cache response
                        return jsonify(result)
                except:
                    pass
            
            try:
                result = analyze_with_enhanced_ai(data)
                result['processTime'] = int((time.time() - start_time) * 1000)
                result['cached'] = False
                
                # Cache the result
                if redis_client:
                    try:
                        redis_client.setex(cache_key, 300, json.dumps(result))  # 5 min cache
                    except:
                        pass
                
                # Update BlockDAG if high risk
                if result.get('riskScore', 0) > 70:
                    update_blockdag_risk(data, result)
                
                return jsonify(result)
            except Exception as e:
                return jsonify({
                    "error": str(e),
                    "riskScore": 50,
                    "provider": "akash-fallback",
                    "threatType": "Analysis Failed"
                }), 500
        
        @app.route('/blockdag/stats')
        def blockdag_stats():
            try:
                blockdag_rpc = os.getenv('BLOCKDAG_RPC', 'https://rpc.blockdag.network')
                response = requests.get(f"{blockdag_rpc}/api/v1/stats", timeout=10)
                if response.status_code == 200:
                    return jsonify({
                        "success": True,
                        "stats": response.json(),
                        "provider": "akash-blockdag"
                    })
                else:
                    return jsonify({"error": "BlockDAG API unavailable"}), 503
            except Exception as e:
                return jsonify({"error": str(e)}), 500
        
        @app.route('/blockdag/health')
        def blockdag_health():
            try:
                blockdag_rpc = os.getenv('BLOCKDAG_RPC', 'https://rpc.blockdag.network')
                response = requests.get(f"{blockdag_rpc}/api/v1/health", timeout=5)
                return jsonify({
                    "success": True,
                    "healthy": response.status_code == 200,
                    "provider": "akash-blockdag"
                })
            except:
                return jsonify({
                    "success": False,
                    "healthy": False,
                    "provider": "akash-blockdag"
                })
        
        def generate_cache_key(tx_data):
            # Create a hash of transaction data for caching
            key_data = f"{tx_data.get('hash', '')}{tx_data.get('from', '')}{tx_data.get('to', '')}"
            return f"tx_analysis:{hashlib.md5(key_data.encode()).hexdigest()}"
        
        def analyze_with_enhanced_ai(tx_data):
            prompt = build_enhanced_analysis_prompt(tx_data)
            
            # Try Grok first with enhanced prompt
            if grok_client:
                try:
                    response = grok_client.chat.completions.create(
                        model="mixtral-8x7b-32768",
                        messages=[
                            {"role": "system", "content": "You are an advanced DeFi security expert with BlockDAG knowledge. Respond only with valid JSON."},
                            {"role": "user", "content": prompt}
                        ],
                        temperature=0.1,
                        max_tokens=1500
                    )
                    
                    result = json.loads(response.choices[0].message.content)
                    result['provider'] = 'grok-akash-enhanced'
                    result['gpu_accelerated'] = True
                    return result
                except Exception as e:
                    print(f"Enhanced Grok failed: {e}")
            
            # Try Gemini with enhanced analysis
            if gemini_model:
                try:
                    response = gemini_model.generate_content(prompt)
                    text = response.text
                    start = text.find('{')
                    end = text.rfind('}') + 1
                    if start != -1 and end != 0:
                        result = json.loads(text[start:end])
                        result['provider'] = 'gemini-akash-enhanced'
                        result['gpu_accelerated'] = True
                        return result
                except Exception as e:
                    print(f"Enhanced Gemini failed: {e}")
            
            # Enhanced fallback with BlockDAG awareness
            return {
                "riskScore": calculate_heuristic_risk(tx_data),
                "threatType": detect_threat_pattern(tx_data),
                "confidence": 0.75,
                "reasoning": "Enhanced heuristic analysis with BlockDAG patterns",
                "provider": "akash-enhanced-heuristic",
                "indicators": analyze_transaction_patterns(tx_data),
                "blockdag_compatible": True
            }
        
        def build_enhanced_analysis_prompt(tx_data):
            return f"""Analyze this DeFi transaction with advanced BlockDAG network awareness:
        
        Transaction Details:
        Hash: {tx_data.get('hash', 'N/A')}
        From: {tx_data.get('from', 'N/A')}
        To: {tx_data.get('to', 'N/A')}
        Value: {tx_data.get('value', 'N/A')}
        Gas: {tx_data.get('gasLimit', 'N/A')}
        Data: {tx_data.get('data', 'N/A')}
        
        Advanced Analysis Required:
        1. Flash loan attack patterns
        2. MEV sandwich attacks
        3. Rug pull indicators
        4. Governance token exploits
        5. Cross-chain bridge vulnerabilities
        6. BlockDAG-specific attack vectors
        7. DAG structure manipulation attempts
        8. Parallel transaction conflicts
        
        Consider BlockDAG Features:
        - DAG structure integrity
        - Parallel processing implications
        - Consensus mechanism attacks
        - Network topology exploitation
        
        Respond with enhanced JSON:
        {{
          "riskScore": <0-100>,
          "threatType": "<specific threat or Normal Transaction>",
          "confidence": <0.0-1.0>,
          "reasoning": "<detailed technical explanation>",
          "indicators": ["<specific risk factors>"],
          "blockdagRisk": <0-100>,
          "dagVulnerabilities": ["<DAG-specific risks>"],
          "mitigationSuggestions": ["<security recommendations>"],
          "severityLevel": "<LOW|MEDIUM|HIGH|CRITICAL>"
        }}"""
        
        def calculate_heuristic_risk(tx_data):
            risk = 30  # Base risk
            
            # Check for high-value transactions
            try:
                value = float(tx_data.get('value', '0'))
                if value > 100:  # High value
                    risk += 20
                elif value > 10:
                    risk += 10
            except:
                pass
            
            # Check for contract interactions
            if tx_data.get('data') and len(tx_data.get('data', '')) > 10:
                risk += 15
            
            # Check for suspicious patterns
            from_addr = tx_data.get('from', '').lower()
            to_addr = tx_data.get('to', '').lower()
            
            if from_addr == to_addr:
                risk += 25  # Self-transaction
            
            return min(risk, 100)
        
        def detect_threat_pattern(tx_data):
            patterns = [
                "Normal Transaction",
                "Potential MEV Attack",
                "Suspicious Contract Interaction",
                "High-Value Transfer",
                "Complex Transaction Pattern"
            ]
            
            risk = calculate_heuristic_risk(tx_data)
            if risk > 80:
                return "High Risk Transaction"
            elif risk > 60:
                return "Suspicious Contract Interaction"
            elif risk > 40:
                return "Potential MEV Attack"
            else:
                return "Normal Transaction"
        
        def analyze_transaction_patterns(tx_data):
            indicators = []
            
            if tx_data.get('data') and len(tx_data.get('data', '')) > 100:
                indicators.append("complex-contract-call")
            
            try:
                value = float(tx_data.get('value', '0'))
                if value > 50:
                    indicators.append("high-value-transfer")
            except:
                pass
            
            if tx_data.get('gasLimit'):
                try:
                    gas = int(tx_data.get('gasLimit', '0'))
                    if gas > 500000:
                        indicators.append("high-gas-usage")
                except:
                    pass
            
            return indicators if indicators else ["standard-transaction"]
        
        def update_blockdag_risk(tx_data, analysis_result):
            try:
                blockdag_api = os.getenv('BLOCKDAG_API')
                blockdag_rpc = os.getenv('BLOCKDAG_RPC')
                
                if not blockdag_api or not blockdag_rpc:
                    return
                
                risk_data = {
                    "contractAddress": tx_data.get('to', ''),
                    "riskScore": analysis_result.get('riskScore', 0),
                    "threatType": analysis_result.get('threatType', 'Unknown'),
                    "timestamp": int(time.time())
                }
                
                headers = {
                    "Authorization": f"Bearer {blockdag_api}",
                    "Content-Type": "application/json"
                }
                
                requests.post(
                    f"{blockdag_rpc}/api/v1/risk-profile",
                    json=risk_data,
                    headers=headers,
                    timeout=5
                )
                print(f"‚úÖ Updated BlockDAG risk profile for {tx_data.get('to', '')}")
            except Exception as e:
                print(f"‚ö†Ô∏è Failed to update BlockDAG: {e}")
        
        if __name__ == '__main__':
            print("üöÄ Enhanced DeFi AI Service starting on Akash...")
            print(f"Grok available: {grok_client is not None}")
            print(f"Gemini available: {gemini_model is not None}")
            print(f"Cache available: {redis_client is not None}")
            print(f"GPU acceleration: {os.getenv('GPU_ACCELERATION')}")
            print(f"BlockDAG integration: {bool(os.getenv('BLOCKDAG_API'))}")
            app.run(host='0.0.0.0', port=8080)
        EOF
        python enhanced_ai_service.py

  ai-cache-redis:
    image: redis:7-alpine
    expose:
      - port: 6379
        to:
          - service: defi-guard-ai
    command:
      - redis-server
      - --maxmemory
      - 1gb
      - --maxmemory-policy
      - allkeys-lru
      - --save
      - ""
      - --appendonly
      - "no"

  defi-guard-frontend:
    image: node:18-alpine
    expose:
      - port: 3000
        as: 3000
        to:
          - global: true
    command:
      - "sh"
      - "-c"
    args:
      - |
        npm install -g serve
        mkdir -p build
        cat > build/index.html << 'EOF'
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>DeFi Transaction Guard - Akash Network</title>
            <style>
                * { margin: 0; padding: 0; box-sizing: border-box; }
                body {
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
                    color: #ffffff;
                    min-height: 100vh;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                }
                .container {
                    max-width: 1200px;
                    padding: 2rem;
                    text-align: center;
                }
                .header {
                    margin-bottom: 3rem;
                }
                .title {
                    font-size: 3rem;
                    font-weight: 700;
                    background: linear-gradient(45deg, #00d4ff, #ff6b6b, #4ecdc4);
                    -webkit-background-clip: text;
                    -webkit-text-fill-color: transparent;
                    margin-bottom: 1rem;
                }
                .subtitle {
                    font-size: 1.2rem;
                    color: #a0a0a0;
                    margin-bottom: 2rem;
                }
                .features {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                    gap: 2rem;
                    margin: 3rem 0;
                }
                .feature-card {
                    background: rgba(255, 255, 255, 0.05);
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 15px;
                    padding: 2rem;
                    transition: transform 0.3s ease;
                }
                .feature-card:hover {
                    transform: translateY(-5px);
                }
                .feature-icon {
                    font-size: 3rem;
                    margin-bottom: 1rem;
                }
                .feature-title {
                    font-size: 1.5rem;
                    margin-bottom: 1rem;
                    color: #00d4ff;
                }
                .status-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                    gap: 1rem;
                    margin: 2rem 0;
                }
                .status-item {
                    background: rgba(0, 212, 255, 0.1);
                    border: 1px solid rgba(0, 212, 255, 0.3);
                    border-radius: 10px;
                    padding: 1rem;
                }
                .status-label {
                    font-size: 0.9rem;
                    color: #a0a0a0;
                    margin-bottom: 0.5rem;
                }
                .status-value {
                    font-size: 1.2rem;
                    font-weight: 600;
                    color: #00d4ff;
                }
                .powered-by {
                    margin-top: 3rem;
                    padding: 2rem;
                    background: rgba(255, 255, 255, 0.03);
                    border-radius: 15px;
                }
                .tech-stack {
                    display: flex;
                    justify-content: center;
                    gap: 2rem;
                    flex-wrap: wrap;
                    margin-top: 1rem;
                }
                .tech-item {
                    background: rgba(255, 107, 107, 0.1);
                    border: 1px solid rgba(255, 107, 107, 0.3);
                    border-radius: 25px;
                    padding: 0.5rem 1rem;
                    font-size: 0.9rem;
                }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1 class="title">üõ°Ô∏è DeFi Transaction Guard</h1>
                    <p class="subtitle">AI-Powered Security on Akash Network with BlockDAG Integration</p>
                </div>
                
                <div class="features">
                    <div class="feature-card">
                        <div class="feature-icon">ü§ñ</div>
                        <h3 class="feature-title">AI-Powered Analysis</h3>
                        <p>Real-time transaction analysis using Grok and Gemini AI models with GPU acceleration</p>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon">üîó</div>
                        <h3 class="feature-title">BlockDAG Integration</h3>
                        <p>Advanced DAG structure validation and parallel transaction security analysis</p>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon">‚ö°</div>
                        <h3 class="feature-title">Akash Network</h3>
                        <p>Decentralized cloud deployment with GPU support and global availability</p>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon">üö®</div>
                        <h3 class="feature-title">Real-time Protection</h3>
                        <p>Instant threat detection for flash loans, MEV attacks, and rug pulls</p>
                    </div>
                </div>
                
                <div class="status-grid">
                    <div class="status-item">
                        <div class="status-label">Service Status</div>
                        <div class="status-value">üü¢ Online</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">AI Models</div>
                        <div class="status-value">Grok + Gemini</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Network</div>
                        <div class="status-value">Akash + BlockDAG</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">GPU Acceleration</div>
                        <div class="status-value">‚úÖ Enabled</div>
                    </div>
                </div>
                
                <div class="powered-by">
                    <h3>Powered By</h3>
                    <div class="tech-stack">
                        <span class="tech-item">Akash Network</span>
                        <span class="tech-item">BlockDAG</span>
                        <span class="tech-item">Grok AI</span>
                        <span class="tech-item">Gemini AI</span>
                        <span class="tech-item">Redis Cache</span>
                        <span class="tech-item">GPU Computing</span>
                    </div>
                </div>
            </div>
            
            <script>
                // Auto-refresh status every 30 seconds
                setInterval(() => {
                    fetch('/health')
                        .then(response => response.json())
                        .then(data => {
                            console.log('Health check:', data);
                        })
                        .catch(error => {
                            console.error('Health check failed:', error);
                        });
                }, 30000);
            </script>
        </body>
        </html>
        EOF
        serve -s build -l 3000

  monitoring-prometheus:
    image: prom/prometheus:latest
    expose:
      - port: 9090
        as: 9091
        to:
          - global: true
    command:
      - "sh"
      - "-c"
    args:
      - |
        cat > /etc/prometheus/prometheus.yml << 'EOF'
        global:
          scrape_interval: 15s
          evaluation_interval: 15s
        
        scrape_configs:
          - job_name: 'defi-guard-ai'
            static_configs:
              - targets: ['defi-guard-ai:9090']
            scrape_interval: 10s
            metrics_path: /metrics
        
          - job_name: 'prometheus'
            static_configs:
              - targets: ['localhost:9090']
        EOF
        prometheus --config.file=/etc/prometheus/prometheus.yml --storage.tsdb.path=/prometheus --web.console.libraries=/etc/prometheus/console_libraries --web.console.templates=/etc/prometheus/consoles --web.enable-lifecycle

profiles:
  compute:
    defi-guard-ai:
      resources:
        cpu:
          units: 4.0
        memory:
          size: 8Gi
        storage:
          size: 20Gi
        gpu:
          units: 1
          attributes:
            vendor:
              nvidia:
                - model: rtx4090
                - model: rtx3080
                - model: a100
                - model: v100
                - model: rtx3070
    ai-cache-redis:
      resources:
        cpu:
          units: 1.0
        memory:
          size: 2Gi
        storage:
          size: 5Gi
    defi-guard-frontend:
      resources:
        cpu:
          units: 1.0
        memory:
          size: 2Gi
        storage:
          size: 5Gi
    monitoring-prometheus:
      resources:
        cpu:
          units: 1.0
        memory:
          size: 4Gi
        storage:
          size: 10Gi

  placement:
    akash:
      attributes:
        host: akash
        datacenter: us-west
        gpu: nvidia
      signedBy:
        anyOf:
          - "akash1365yvmc4s7awdyj3n2sav7xfx76adc6dnmlx63"
          - "akash18qa2a2ltfyvkyj0ggj3hkvuj6twzyumuaru9s4"
      pricing:
        defi-guard-ai:
          denom: uakt
          amount: 5000
        ai-cache-redis:
          denom: uakt
          amount: 1000
        defi-guard-frontend:
          denom: uakt
          amount: 1000
        monitoring-prometheus:
          denom: uakt
          amount: 1500

deployment:
  defi-guard-ai:
    akash:
      profile: defi-guard-ai
      count: 1
  ai-cache-redis:
    akash:
      profile: ai-cache-redis
      count: 1
  defi-guard-frontend:
    akash:
      profile: defi-guard-frontend
      count: 1
  monitoring-prometheus:
    akash:
      profile: monitoring-prometheus
      count: 1